use crate::{packet, Packet, PayloadGenerator, Sequencer};
use chrono::Local;
use rand::Rng;

pub type G711Packetizer = Packetizer<crate::codecs::g711::G711PayloadGenerator>;
pub type G722Packetizer = Packetizer<crate::codecs::g722::G722PayloadGenerator>;
pub type H264Packetizer = Packetizer<crate::codecs::h264::H264PayloadGenerator>;
pub type OpusPacketizer = Packetizer<crate::codecs::opus::OpusPayloadGenerator>;
pub type VP8Packetizer = Packetizer<crate::codecs::vp8::VP8PayloadGenerator>;
pub type VP9Packetizer = Packetizer<crate::codecs::vp9::VP9PayloadGenerator>;

/// This structure is responsible to packetize payloads that need
/// to be transmited through an RTP channel.
#[derive(Clone, Debug)]
pub struct Packetizer<G: PayloadGenerator + Default> {
    /// The Maximum Transmission Unit (MTU) used by the packetizer to
    /// generates packets.
    pub mtu: usize,

    /// The RTP payload type of the packets generated by the packetizer.
    pub payload_type: u8,

    /// The synchronization source (SSRC) identifier which emitting the
    /// packets.
    pub synchronization_source: u32,

    timestamp: u32,
    generator: G,
    sequencer: Sequencer,
}

impl<G> Packetizer<G>
where
    G: PayloadGenerator + Default,
{
    /// Instanciates a new instance of a packetizer with its parameters.
    pub fn new(mtu: usize, payload_type: u8, ssrc: u32) -> Self {
        Self {
            mtu,
            payload_type,
            synchronization_source: ssrc,
            timestamp: rand::thread_rng().gen(),
            generator: G::default(),
            sequencer: Sequencer::new(),
        }
    }

    /// Transforms the data in a codecs format into a list of RTP packets.
    ///
    /// The data must be in the codec supported by the generator you've
    /// specified when you've instanciated the packetizer.
    pub fn packetize(&mut self, data: &[u8], samples: u32) -> Option<Vec<Packet>> {
        if data.len() == 0 || self.mtu <= packet::HEADER_SIZE {
            return None;
        }

        // Trying to retrieve RTP packets' payloads
        let payloads = self
            .generator
            .generate(self.mtu - packet::HEADER_SIZE, data);
        if let None = payloads {
            return None;
        }

        // Transforming RTP payloads into RTP packets
        let payloads = payloads.unwrap();
        if payloads.len() == 0 {
            return None;
        }

        let packets: Vec<Packet> = payloads
            .iter()
            .enumerate()
            .map(|(index, payload)| Packet {
                version: packet::PACKET_VERSION,
                padding: false,
                extension: false,
                marker: index == payload.len() - 1,
                payload_type: self.payload_type,
                sequence_number: self.sequencer.next_sequence_number(),
                timestamp: self.timestamp,
                ssrc: self.synchronization_source,
                csrc: Vec::new(),
                extension_profile: None,
                extension_payload: None,
                payload_offset: packet::HEADER_SIZE,
                payload: Vec::from(&payload[..]),
                raw: None,
            })
            .collect();

        // Refreshing internal timestamp
        self.timestamp += samples;

        Some(packets)
    }

    /// Retrieves the current Unix timestamp of the local system
    /// into its NTP representation.
    pub fn ntp_time(&self) -> u64 {
        to_ntp_time(Local::now().timestamp_nanos() as u64)
    }
}

/// Converts an Unix epoch, in nanoseconds, into a NTP time.
fn to_ntp_time(unix_epoch: u64) -> u64 {
    let s = unix_epoch / 1_000_000_000;
    let s = s + 0x83aa7e80;
    let s = s << 32;

    let f = unix_epoch % 1_000_000_000;
    let f = f << 32;
    let f = f / 1_000_000_000;

    s | f
}

#[cfg(test)]
mod tests {
    use super::*;
    use chrono::{FixedOffset, TimeZone};

    #[test]
    fn it_packetizes_arbitrary_data() {
        // We'll use the G722 codecs here because it's simple and accepts an array filled of zeros
        // as valid data.
        let mut packetizer = G722Packetizer::new(100, 98, 0x1234abcd);
        let data = [0u8; 128];

        let packets = packetizer.packetize(&data, 2000);
        assert!(packets.is_some());

        let packets = packets.unwrap();
        assert_eq!(2, packets.len());
    }

    #[test]
    fn it_returns_none_when_mtu_is_too_small() {
        let mut packetizer = G722Packetizer::new(5, 98, 0x1234abcd);
        let data = [0u8; 128];

        let packets = packetizer.packetize(&data, 2000);
        assert!(packets.is_none());
    }

    #[test]
    fn it_returns_none_when_there_is_no_data_to_packetize() {
        let mut packetizer = G722Packetizer::new(100, 98, 0x1234abcd);

        let packets = packetizer.packetize(&[], 2000);
        assert!(packets.is_none());
    }

    #[test]
    fn it_converts_an_epoch_into_a_ntp_time() {
        let time = FixedOffset::west(5 * 3600)
            .ymd(1985, 6, 23)
            .and_hms(4, 0, 0);
        assert_eq!(
            to_ntp_time(time.timestamp_nanos() as u64),
            0xa0c65b1000000000
        );

        let time = Local.ymd(2020, 1, 28).and_hms(11, 34, 23);
        assert_eq!(
            to_ntp_time(time.timestamp_nanos() as u64),
            0xe1da8caf00000000
        );
    }
}
